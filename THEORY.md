# Теоретическая часть - Вариант 8

## Задание

Входной язык содержит логические выражения, разделенные символом `;` (точка с запятой). 
Логические выражения состоят из:
- Идентификаторов
- Констант `0` и `1`
- Знака присваивания `:=`
- Знаков операций `or`, `xor`, `and`, `not`
- Круглых скобок `(`, `)`

Форма комментариев: 
- Однострочные: `// комментарий`
- Многострочные: `/* комментарий */`

## Регулярная грамматика лексем

### Грамматика в форме Бэкуса-Наура

```
G = ({S, I, K, A, C}, {буквы, цифры, 0, 1, :, =, символы}, P, S)

P:
  S → I | K | A | C | ( | ) | ;
  
  I → буква | I буква | I цифра | I _
  
  K → o r | x o r | a n d | n o t
  
  A → : =
  
  C → 0 | 1

Где:
- S - начальный символ
- I - идентификатор
- K - ключевое слово (keyword)
- A - присваивание (assignment)
- C - константа (constant)
```

### Регулярные выражения

Лексемы можно также описать регулярными выражениями:

```
Идентификатор:    [a-zA-Z_][a-zA-Z0-9_]*
Константа:        0|1
Присваивание:     :=
Ключевые слова:   or|xor|and|not
Левая скобка:     \(
Правая скобка:    \)
Точка с запятой:  ;
Комментарий (//): //.*
Комментарий (/*): /\*(.|\n)*?\*/
```

## Конечный автомат

### Описание состояний

```
Q = {N, ID, KEY, COLON, CONST, LPAR, RPAR, SEMI, COMM, S, E}

Где:
- N     - начальное состояние
- ID    - состояние идентификатора
- KEY   - состояние ключевого слова
- COLON - состояние двоеточия (ожидание =)
- CONST - состояние константы
- LPAR  - левая скобка
- RPAR  - правая скобка
- SEMI  - точка с запятой
- COMM  - комментарий
- S     - конечное состояние
- E     - состояние ошибки
```

### Функция переходов δ

Алфавит: Σ = {буквы, цифры, 0, 1, :, =, (, ), ;, /, *, пробелы}

```
Из состояния N (начальное):
  δ(N, буква) = ID
  δ(N, 0) = CONST
  δ(N, 1) = CONST
  δ(N, :) = COLON
  δ(N, () = LPAR → S
  δ(N, )) = RPAR → S
  δ(N, ;) = SEMI → S
  δ(N, /) = COMM (если следующий символ / или *)
  δ(N, пробел) = N (пропуск)
  δ(N, остальное) = E

Из состояния ID (идентификатор):
  δ(ID, буква) = ID
  δ(ID, цифра) = ID
  δ(ID, _) = ID
  δ(ID, пробел|разделитель) = KEY или S
  
Из состояния KEY (проверка ключевого слова):
  Если идентификатор = "or"|"xor"|"and"|"not" → S (ключевое слово)
  Иначе → S (обычный идентификатор)

Из состояния COLON (двоеточие):
  δ(COLON, =) = S (присваивание :=)
  δ(COLON, остальное) = E

Из состояния CONST (константа):
  δ(CONST, пробел|разделитель) = S

Из состояния COMM (комментарий):
  δ(COMM, символы до \n) = N (для //)
  δ(COMM, символы до */) = N (для /* */)

Конечные состояния: F = {S}
```

### Граф переходов КА

```
                    буква
         ┌──────────────────────┐
         │                      ↓
         │              ┌───────────┐  буква,цифра,_
         │              │    ID     │◄──────────┐
         │              └───────────┘           │
         │                      │               │
         │                      │ !буква        │
         │                      ↓               │
    ┌────────┐  0,1        ┌───────────┐        │
    │   N    │────────────►│   CONST   │        │
    │ (нач.) │             └───────────┘        │
    └────────┘                  │               │
         │                      ↓               │
         │ :              ┌───────────┐         │
         ├───────────────►│   COLON   │         │
         │                └───────────┘         │
         │                      │ =             │
         │ (                    ↓               │
         ├───────────►LPAR──►┌──────┐          │
         │                    │  S   │◄─────────┘
         │ )                  │(кон.)│
         ├───────────►RPAR──►└──────┘
         │                       ↑
         │ ;                     │
         └───────────►SEMI────────┘
         │
         │ /
         └───────────►COMM────────┐
                                  │
                                  ↓
                                  N (возврат)
```

## Таблица токенов (лексем)

| Тип лексемы       | Внутреннее представление | Примеры            |
|-------------------|--------------------------|--------------------| 
| Идентификатор     | TokIdentifier            | a, var1, result_x  |
| Константа         | TokConstant              | 0, 1               |
| Присваивание      | TokAssignment            | :=                 |
| Логическое ИЛИ    | TokOr                    | or                 |
| Исключающее ИЛИ   | TokXor                   | xor                |
| Логическое И      | TokAnd                   | and                |
| Логическое НЕ     | TokNot                   | not                |
| Левая скобка      | TokLeftParen             | (                  |
| Правая скобка     | TokRightParen            | )                  |
| Точка с запятой   | TokSemicolon             | ;                  |
| Комментарий       | TokComment               | //, /* */          |
| Конец файла       | TokEOF                   | EOF                |
| Ошибка            | TokError                 | недопустимый символ|

## Алгоритм работы лексического анализатора

### Псевдокод

```
function Analyze(input: string):
    position := 0
    tokens := []
    
    while position < length(input):
        skipWhitespace()
        
        if isComment():
            skipComment()
            continue
        
        current_char := input[position]
        
        match current_char:
            case letter:
                token := readIdentifier()
                if token in ["or", "xor", "and", "not"]:
                    tokens.add(Keyword(token))
                else:
                    tokens.add(Identifier(token))
            
            case '0', '1':
                tokens.add(Constant(current_char))
            
            case ':':
                if next_char == '=':
                    tokens.add(Assignment(":="))
                    position++
                else:
                    error("Expected '=' after ':'")
            
            case '(':
                tokens.add(LeftParen)
            
            case ')':
                tokens.add(RightParen)
            
            case ';':
                tokens.add(Semicolon)
            
            default:
                error("Unexpected character")
        
        position++
    
    return tokens
```

### Сложность алгоритма

- **Временная сложность**: O(n), где n - длина входной строки
- **Пространственная сложность**: O(m), где m - количество токенов

Каждый символ обрабатывается ровно один раз, что обеспечивает линейную сложность.

## Примеры работы

### Пример 1: Простое выражение

**Вход:**
```
a := 1;
```

**Таблица токенов:**
| # | Лексема | Тип              | Позиция     |
|---|---------|------------------|-------------|
| 1 | a       | Идентификатор    | строка 1, столбец 1 |
| 2 | :=      | Присваивание     | строка 1, столбец 3 |
| 3 | 1       | Константа        | строка 1, столбец 6 |
| 4 | ;       | Точка с запятой  | строка 1, столбец 7 |

### Пример 2: Логическое выражение

**Вход:**
```
result := (a or b) and not c;
```

**Таблица токенов:**
| # | Лексема | Тип                | Позиция     |
|---|---------|--------------------|-------------|
| 1 | result  | Идентификатор      | строка 1, столбец 1  |
| 2 | :=      | Присваивание       | строка 1, столбец 8  |
| 3 | (       | Левая скобка       | строка 1, столбец 11 |
| 4 | a       | Идентификатор      | строка 1, столбец 12 |
| 5 | or      | Ключевое слово (OR)| строка 1, столбец 14 |
| 6 | b       | Идентификатор      | строка 1, столбец 17 |
| 7 | )       | Правая скобка      | строка 1, столбец 18 |
| 8 | and     | Ключевое слово (AND)| строка 1, столбец 20 |
| 9 | not     | Ключевое слово (NOT)| строка 1, столбец 24 |
| 10| c       | Идентификатор      | строка 1, столбец 28 |
| 11| ;       | Точка с запятой    | строка 1, столбец 29 |

### Пример 3: С комментариями

**Вход:**
```
// Инициализация
a := 1; /* это константа */
```

**Таблица токенов:**
| # | Лексема | Тип              | Позиция     |
|---|---------|------------------|-------------|
| 1 | a       | Идентификатор    | строка 2, столбец 1 |
| 2 | :=      | Присваивание     | строка 2, столбец 3 |
| 3 | 1       | Константа        | строка 2, столбец 6 |
| 4 | ;       | Точка с запятой  | строка 2, столбец 7 |

Комментарии пропускаются и не попадают в таблицу токенов.

## Обработка ошибок

Лексический анализатор обнаруживает следующие типы ошибок:

1. **Недопустимый символ**: символ не принадлежит алфавиту языка
   ```
   Пример: a := 1 & b;
   Ошибка: Неожиданный символ '&' (строка 1, столбец 8)
   ```

2. **Неверная константа**: цифра не 0 и не 1
   ```
   Пример: a := 5;
   Ошибка: Неожиданный символ '5' (строка 1, столбец 6)
   ```

3. **Неполный оператор присваивания**: : без =
   ```
   Пример: a : 1;
   Ошибка: Неожиданный символ ':' (строка 1, столбец 3)
   ```

4. **Незакрытый комментарий**: /* без */
   ```
   Пример: a := 1; /* комментарий
   Ошибка: Незакрытый комментарий (строка 1, столбец 9)
   ```

## Выводы

Реализованный лексический анализатор:

1. ✅ Корректно распознает все типы лексем согласно варианту 8
2. ✅ Построен на основе детерминированного конечного автомата
3. ✅ Имеет линейную временную сложность O(n)
4. ✅ Обрабатывает комментарии обоих видов
5. ✅ Выдает детальные сообщения об ошибках с указанием позиции
6. ✅ Поддерживает идентификаторы неограниченной длины
7. ✅ Готов к интеграции с синтаксическим анализатором

Анализатор может быть использован как самостоятельное приложение для проверки 
корректности логических выражений или как первый этап компилятора для 
специализированного языка логических операций.
